<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PropTrader - Live Sports Trading</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .navbar-brand {
            font-weight: bold;
            font-size: 1.5rem;
        }
        .card {
            border: none;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .card:hover {
            transform: translateY(-5px);
        }
        .trading-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .status-badge {
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        .status-live {
            background: #dc3545;
            color: white;
            animation: pulse 2s infinite;
        }
        .status-final {
            background: #6c757d;
            color: white;
        }
        .status-upcoming {
            background: #28a745;
            color: white;
        }
        .status-cancelled {
            background: #ffc107;
            color: #212529;
        }
        .status-ruled-out {
            background: #6c757d;
            color: white;
        }
        .status-over-hit {
            background: #28a745;
            color: white;
            animation: pulse 1s infinite;
        }
        .status-push {
            background: #0d6efd;
            color: white;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        .live-price {
            font-size: 1.2rem;
            font-weight: bold;
            color: #dc3545;
        }
        .game-info {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 10px;
            margin: 10px 0;
        }
        .player-stats {
            background: #e9ecef;
            border-radius: 8px;
            padding: 8px;
            margin: 5px 0;
        }
        .btn-trade {
            border-radius: 25px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .btn-trade:hover {
            transform: scale(1.05);
        }
        .filters {
            background: rgba(255,255,255,0.9);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .portfolio-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #007bff;
        }
        
        .portfolio-item .btn {
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
        }
        .trade-history {
            max-height: 400px;
            overflow-y: auto;
        }
        
        /* Contract availability styling */
        .contract-count {
            font-weight: bold;
        }
        .contract-count.low {
            color: #dc3545;
            animation: pulse 1s infinite;
        }
        .contract-count.few {
            color: #ffc107;
        }
        .contract-count.normal {
            color: #6c757d;
        }
        
        /* Disabled button styling */
        .btn-secondary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* Contract availability indicators */
        .contract-indicator {
            display: inline-block;
            margin-left: 5px;
        }
        .contract-indicator.low::after {
            content: " ‚ö†Ô∏è";
            color: #dc3545;
        }
        .contract-indicator.few::after {
            content: " ‚ö°";
            color: #ffc107;
        }
        
        .pending-order-item {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #ffc107;
        }
        
        .trade-item {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            border-left: 3px solid #28a745;
        }
        .trade-sell {
            border-left-color: #dc3545;
        }
        .demo-banner {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        /* WebSocket and Live Updates Styling */
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 300px;
            max-width: 400px;
            animation: slideInRight 0.3s ease-out;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .toast-header {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            padding: 10px 15px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .toast-body {
            padding: 15px;
            color: #212529;
        }
        
        .btn-close {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #6c757d;
        }
        
        .btn-close:hover {
            color: #dc3545;
        }
        
        .price-update {
            animation: priceFlash 1s ease-in-out;
        }
        
        @keyframes priceFlash {
            0% { background-color: transparent; }
            50% { background-color: #fff3cd; }
            100% { background-color: transparent; }
        }
        
        .live-indicator {
            background: #dc3545;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            margin-bottom: 10px;
            display: inline-block;
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="#">
                <i class="fas fa-chart-line"></i> PropTrader
            </a>
            <div class="navbar-nav ms-auto">
                <span class="navbar-text me-3">
                    <i class="fas fa-wifi"></i> 
                    <span id="websocket-status" class="badge bg-secondary">üî¥ Offline</span>
                </span>
                <span class="navbar-text" id="user-info">
                    <i class="fas fa-user"></i> <span id="username">Demo User</span>
                    <button class="btn btn-outline-light btn-sm ms-2" onclick="logout()">Logout</button>
                </span>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <!-- Demo Banner -->
        <div class="demo-banner">
            <i class="fas fa-info-circle"></i> <strong>Demo Mode:</strong> This is a local development version. No real money or authentication required.
        </div>

        <!-- Login/Register Forms -->
        <div id="auth-forms" class="row justify-content-center" style="display: none;">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-body">
                        <ul class="nav nav-tabs" id="authTabs" role="tablist">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active" id="login-tab" data-bs-toggle="tab" data-bs-target="#login" type="button">Login</button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="register-tab" data-bs-toggle="tab" data-bs-target="#register" type="button">Register</button>
                            </li>
                        </ul>
                        <div class="tab-content" id="authTabContent">
                            <div class="tab-pane fade show active" id="login">
                                <form id="login-form" class="mt-3">
                                    <div class="mb-3">
                                        <label for="login-username" class="form-label">Username</label>
                                        <input type="text" class="form-control" id="login-username" value="demo" required>
                                    </div>
                                    <div class="mb-3">
                                        <label for="login-password" class="form-label">Password</label>
                                        <input type="password" class="form-control" id="login-password" value="demo" required>
                                    </div>
                                    <button type="submit" class="btn btn-primary w-100">Login (Demo)</button>
                                </form>
                            </div>
                            <div class="tab-pane fade" id="register">
                                <form id="register-form" class="mt-3">
                                    <div class="row">
                                        <div class="col-md-6">
                                            <div class="mb-3">
                                                <label for="register-first-name" class="form-label">First Name</label>
                                                <input type="text" class="form-control" id="register-first-name">
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <div class="mb-3">
                                                <label for="register-last-name" class="form-label">Last Name</label>
                                                <input type="text" class="form-control" id="register-last-name">
                                            </div>
                                        </div>
                                    </div>
                                    <div class="mb-3">
                                        <label for="register-username" class="form-label">Username *</label>
                                        <input type="text" class="form-control" id="register-username" required>
                                    </div>
                                    <div class="mb-3">
                                        <label for="register-email" class="form-label">Email *</label>
                                        <input type="email" class="form-control" id="register-email" required>
                                    </div>
                                    <div class="mb-3">
                                        <label for="register-password" class="form-label">Password *</label>
                                        <input type="password" class="form-control" id="register-password" required minlength="8">
                                        <div class="form-text">Password must be at least 8 characters long</div>
                                    </div>
                                    <div class="mb-3">
                                        <label for="register-date-of-birth" class="form-label">Date of Birth</label>
                                        <input type="date" class="form-control" id="register-date-of-birth">
                                    </div>
                                    <div class="mb-3">
                                        <label for="register-phone" class="form-label">Phone Number</label>
                                        <input type="tel" class="form-control" id="register-phone">
                                    </div>
                                    <div class="mb-3">
                                        <label for="register-address" class="form-label">Address</label>
                                        <textarea class="form-control" id="register-address" rows="2"></textarea>
                                    </div>
                                    <div class="row">
                                        <div class="col-md-6">
                                            <div class="mb-3">
                                                <label for="register-city" class="form-label">City</label>
                                                <input type="text" class="form-control" id="register-city">
                                            </div>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="mb-3">
                                                <label for="register-state" class="form-label">State</label>
                                                <input type="text" class="form-control" id="register-state">
                                            </div>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="mb-3">
                                                <label for="register-zip" class="form-label">ZIP Code</label>
                                                <input type="text" class="form-control" id="register-zip">
                                            </div>
                                        </div>
                                    </div>
                                    <div class="mb-3">
                                        <label for="register-country" class="form-label">Country</label>
                                        <select class="form-control" id="register-country">
                                            <option value="US">United States</option>
                                            <option value="CA">Canada</option>
                                            <option value="UK">United Kingdom</option>
                                            <option value="AU">Australia</option>
                                            <option value="Other">Other</option>
                                        </select>
                                    </div>
                                    <button type="submit" class="btn btn-success w-100">Register</button>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Dashboard -->
        <div id="dashboard">
            <div class="row">
                <div class="col-md-8">
                    <!-- Market Section -->
                    <div class="card">
                        <div class="card-header">
                            <h5><i class="fas fa-chart-bar"></i> Live Market</h5>
                        </div>
                        <div class="card-body">
                            <!-- Filters -->
                            <div class="filters">
                                <div class="row">
                                    <div class="col-md-3">
                                        <label class="form-label">Sport</label>
                                        <select class="form-select" id="sport-filter">
                                            <option value="">All Sports</option>
                                            <option value="MLB">MLB</option>
                                            <option value="NBA">NBA</option>
                                            <option value="NFL">NFL</option>
                                        </select>
                                    </div>
                                    <div class="col-md-3">
                                        <label class="form-label">Difficulty</label>
                                        <select class="form-select" id="difficulty-filter">
                                            <option value="">All Difficulties</option>
                                            <option value="EASY">Easy</option>
                                            <option value="MEDIUM">Medium</option>
                                            <option value="HARD">Hard</option>
                                        </select>
                                    </div>
                                    <div class="col-md-3">
                                        <label class="form-label">Status</label>
                                        <select class="form-select" id="status-filter">
                                            <option value="">All Status</option>
                                            <option value="UPCOMING">Upcoming</option>
                                            <option value="LIVE">Live</option>
                                            <option value="FINAL">Final</option>
                                        </select>
                                    </div>
                                                                <div class="col-md-3" id="stat-category-container" style="display: none;">
                                <label for="stat-category-filter" class="form-label text-muted small">Stat Category</label>
                                <select class="form-select" id="stat-category-filter">
                                    <option value="">All Categories</option>
                                    <option value="rbis"> RBIs</option>
                                    <option value="runs"> Runs</option>
                                    <option value="total_bases"> Total Bases</option>
                                    <option value="hits"> Hits</option>
                                    <option value="strikeouts"> Strikeouts</option>
                                    <option value="pitches"> Pitches</option>
                                    <option value="era"> ERA</option>
                                </select>
                            </div>
                                </div>
                            </div>

                            <!-- Game Schedule Header -->
                            <div class="mb-3 p-3 bg-light border rounded" id="game-schedule-header" style="display: none;">
                                <h6><i class="fas fa-calendar-alt"></i> Today's Game Schedule (Earliest First)</h6>
                                <div id="game-schedule-content">
                                    <small class="text-muted">Game schedule will appear here...</small>
                                </div>
                            </div>

                            <!-- Props List -->
                            <div id="props-container">
                                <!-- Props will be loaded here -->
                            </div>

                            <!-- Props Status Indicator -->
                            <div class="mt-3 text-center">
                                <small class="text-muted" id="props-status">
                                    <i class="fas fa-info-circle"></i> Loading props...
                                </small>
                                <br>
                                <button type="button" class="btn btn-sm btn-outline-primary mt-2" onclick="refreshProps()">
                                    <i class="fas fa-sync-alt"></i> Refresh Props
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="col-md-4">
                    <!-- Portfolio Section -->
                    <div class="card mb-3">
                        <div class="card-header">
                            <h5><i class="fas fa-briefcase"></i> Portfolio</h5>
                        </div>
                        <div class="card-body">
                            <div class="d-flex justify-content-between mb-3">
                                <span>Balance:</span>
                                <span class="fw-bold" id="user-balance">$10,000.00</span>
                            </div>
                            <div id="portfolio-items">
                                <!-- Portfolio items will be loaded here -->
                            </div>
                        </div>
                    </div>

                    <!-- Pending Transactions -->
                    <div class="card mb-3">
                        <div class="card-header">
                            <h5><i class="fas fa-clock"></i> Pending Orders</h5>
                        </div>
                        <div class="card-body">
                            <div id="pending-orders" class="pending-orders">
                                <!-- Pending orders will be loaded here -->
                            </div>
                        </div>
                    </div>

                    <!-- Trade History -->
                    <div class="card mb-3">
                        <div class="card-header">
                            <h5><i class="fas fa-history"></i> Trade History</h5>
                        </div>
                        <div class="card-body">
                            <div id="trade-history" class="trade-history">
                                <!-- Trade history will be loaded here -->
                            </div>
                        </div>
                    </div>

                    <!-- Leaderboard -->
                    <div class="card mb-3">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5><i class="fas fa-trophy"></i> Leaderboard</h5>
                            <button class="btn btn-sm btn-outline-primary" onclick="refreshLeaderboard()">
                                <i class="fas fa-sync-alt"></i>
                            </button>
                        </div>
                        <div class="card-body">
                            <div id="leaderboard-content">
                                <!-- Leaderboard will be loaded here -->
                            </div>
                        </div>
                    </div>

                    <!-- Platform Stats -->
                    <div class="card">
                        <div class="card-header">
                            <h5><i class="fas fa-chart-line"></i> Platform Stats</h5>
                        </div>
                        <div class="card-body">
                            <div class="d-flex justify-content-between mb-2">
                                <span>Net Profit:</span>
                                <span class="fw-bold" id="platform-profit">$0.00</span>
                            </div>
                            <div class="d-flex justify-content-between mb-2">
                                <span>Total Users:</span>
                                <span class="fw-bold" id="total-users">0</span>
                            </div>
                            <div class="d-flex justify-content-between">
                                <span>Active Today:</span>
                                <span class="fw-bold" id="active-users">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Trading Modal -->
    <div class="modal fade" id="tradingModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="tradingModalTitle">Trade Contract</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="trading-details">
                        <!-- Trading details will be loaded here -->
                    </div>
                    
                    <!-- Market Price Display -->
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label class="form-label">Current Market Price</label>
                            <div class="live-price" id="current-market-price">$0.00</div>
                            <small class="text-muted">Dynamically calculated from order book</small>
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">Available Contracts</label>
                            <div id="available-contracts">0</div>
                            <small class="text-muted">Currently available for trading</small>
                        </div>
                    </div>
                    
                    <!-- Trading Options -->
                    <div class="row">
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h6 class="mb-0"><i class="fas fa-shopping-cart text-success"></i> Buy Options</h6>
                                </div>
                                <div class="card-body" id="buy-options">
                                    <div class="mb-3">
                                        <label class="form-label">Buy Now (Market Price)</label>
                                        <button type="button" class="btn btn-success w-100" onclick="executeTrade('buy', 'market')">
                                            Buy at Market Price
                                        </button>
                                    </div>
                                    <div class="mb-3">
                                        <label class="form-label">Limit Buy Order</label>
                                        <div class="input-group">
                                            <span class="input-group-text">$</span>
                                            <input type="number" class="form-control" id="buy-limit-price" placeholder="0.00" step="0.01" min="0.01" max="99.99">
                                        </div>
                                        <button type="button" class="btn btn-outline-success w-100 mt-2" onclick="executeTrade('buy', 'limit')">
                                            Place Buy Order
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-header">
                                    <h6 class="mb-0"><i class="fas fa-tags text-danger"></i> Sell Options</h6>
                                </div>
                                <div class="card-body" id="sell-options">
                                    <div class="mb-3">
                                        <label class="form-label">Sell Now (Market Price)</label>
                                        <button type="button" class="btn btn-danger w-100" onclick="executeTrade('sell', 'market')">
                                            Sell at Market Price
                                        </button>
                                    </div>
                                    <div class="mb-3">
                                        <label class="form-label">Limit Sell Order</label>
                                        <div class="input-group">
                                            <span class="input-group-text">$</span>
                                            <input type="number" class="form-control" id="sell-limit-price" placeholder="0.00" step="0.01" min="0.01" max="99.99">
                                        </div>
                                        <button type="button" class="btn btn-outline-danger w-100 mt-2" onclick="executeTrade('sell', 'limit')">
                                            Place Sell Order
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Cash Out Option (for final games) -->
                    <div id="cash-out-section" class="mt-3" style="display: none;">
                        <div class="card">
                            <div class="card-header bg-warning text-dark">
                                <h6 class="mb-0"><i class="fas fa-trophy text-warning"></i> Cash Out Contract</h6>
                            </div>
                            <div class="card-body">
                                <p class="text-muted mb-3">Game is finished! Cash out your contract to collect your winnings.</p>
                                <button type="button" class="btn btn-warning w-100" onclick="cashOutContract()">
                                    <i class="fas fa-trophy"></i> Cash Out Contract
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Portfolio Constraints -->
                    <div class="alert alert-info mt-3">
                        <i class="fas fa-info-circle"></i>
                        <strong>Portfolio Limits:</strong> Maximum 10 contracts total, 1 contract per player (any prop type), max 50% from same team (starts after 1st contract). <strong>Pending orders count toward these limits.</strong>
                    </div>
                    
                    <!-- Game Status Info -->
                    <div id="game-status-info" class="alert mt-3" style="display: none;">
                        <i class="fas fa-info-circle"></i>
                        <span id="game-status-message"></span>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Local development - no real API needed
        const API_BASE = 'http://localhost:8007/api';
        let currentUser = { username: 'Demo User', balance: 10000 };
        let liveUpdateInterval = null;
        let userPortfolio = [];
        let tradeHistory = [];
        let pendingOrders = [];
        let orderBook = {}; // Store order book data for each prop

        // Real MLB props loaded from scraper
        let realProps = [];
        
        // Load real MLB props from scraper
        async function loadRealMLBProps() {
            try {
                console.log('üîÑ Loading real MLB props...');
                // Add cache-busting parameter to force refresh
                const timestamp = new Date().getTime();
                
                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                const response = await fetch(`/mlb_props.json?t=${timestamp}`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('üìä Raw MLB props data:', data);
                
                if (!data.props) {
                    console.warn('‚ö†Ô∏è No props found in data');
                    return [];
                }
                
                const realProps = [];
                let propId = 1;
                
                // Create a map of game statuses for quick lookup
                const gameStatuses = {};
                if (data.games) {
                    data.games.forEach(game => {
                        gameStatuses[game.game_id] = game.status;
                    });
                }
                
                for (const [playerId, playerData] of Object.entries(data.props)) {
                    const player = playerData.player_info;
                    const playerProps = playerData.props || [];
                    
                    console.log(`üë§ Processing player: ${player.name} with ${playerProps.length} props`);
                    
                    for (const prop of playerProps) {
                        // Get the game status for this player's game
                        const gameStatus = gameStatuses[player.game_id] || 'UPCOMING';
                        
                        // Check if player is ruled out (this would come from the live tracker)
                        const isPlayerRuledOut = player.status === 'RULED_OUT' || player.status === 'NOT_PLAYING';
                        
                        // Check if this is an over prop that has already hit (would be removed by live tracker)
                        const isOverHit = prop.over_hit === true;
                        
                        // Convert scraper prop format to trading platform format
                        const tradingProp = {
                            id: propId++,
                            player_name: player.name,
                            player_team: player.team_name,
                            player_position: player.position,
                            sport: 'MLB',
                            prop_type: prop.stat.toLowerCase().replace(/\s+/g, '_'),
                            difficulty: prop.type.toUpperCase(),
                            line_value: prop.line,
                            live_contract_price: prop.price,
                            available_contracts: 10,
                            total_contracts: 10,
                            status_badge: isOverHit ? 'OVER_HIT' : (isPlayerRuledOut ? 'RULED_OUT' : gameStatus), // Show OVER_HIT if over already hit
                            is_tradeable: !isOverHit && !isPlayerRuledOut && (gameStatus === 'UPCOMING' || gameStatus === 'LIVE'), // Not tradeable if over hit or ruled out
                            formatted_game_time: prop.game_time || 'TBD',
                            direction: prop.direction,
                            implied_probability: prop.implied_prob,
                            game_id: player.game_id,
                            opponent: prop.opponent || null,
                            player_status: player.status || 'ACTIVE',
                            over_hit: isOverHit
                        };
                        
                        console.log(`üìà Created prop: ${tradingProp.prop_type} ${tradingProp.difficulty} - Status: ${tradingProp.status_badge} - Player Status: ${tradingProp.player_status} - Over Hit: ${tradingProp.over_hit} - Tradeable: ${tradingProp.is_tradeable}`);
                        
                        realProps.push(tradingProp);
                    }
                }
                
                // Sort props by game time (earliest games first)
                realProps.sort((a, b) => {
                    const timeA = a.formatted_game_time;
                    const timeB = b.formatted_game_time;
                    
                    // Extract hour and minute from time strings like "06:10 PM ET"
                    const parseTime = (timeStr) => {
                        if (!timeStr || timeStr === 'TBD') return Infinity;
                        const match = timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
                        if (!match) return Infinity;
                        
                        let hour = parseInt(match[1]);
                        const minute = parseInt(match[2]);
                        const period = match[3].toUpperCase();
                        
                        // Convert to 24-hour format for comparison
                        if (period === 'PM' && hour !== 12) hour += 12;
                        if (period === 'AM' && hour === 12) hour = 0;
                        
                        return hour * 60 + minute;
                    };
                    
                    const timeAValue = parseTime(timeA);
                    const timeBValue = parseTime(timeB);
                    
                    return timeAValue - timeBValue;
                });
                
                console.log(`‚úÖ Successfully loaded ${realProps.length} real MLB props with 10 contracts each, sorted by game time`);
                return realProps;
                
            } catch (error) {
                console.error('Error loading real MLB props:', error);
                console.log('No fallback available - real MLB data required');
                return [];
            }
        }
        
        // Load real NFL props from scraper (parallel to MLB)
        async function loadRealNFLProps() {
            try {
                console.log('üîÑ Loading real NFL props...');
                const timestamp = new Date().getTime();
                
                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                const response = await fetch(`/nfl_props.json?t=${timestamp}`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                if (!data.props) return [];

                const nflProps = [];
                let propId = 100000; // offset to avoid collision

                const gameStatuses = {};
                if (data.games) {
                    data.games.forEach(game => {
                        gameStatuses[game.game_id] = game.status || 'UPCOMING';
                    });
                }

                for (const [playerKey, pd] of Object.entries(data.props)) {
                    const p = pd.player_info || {};
                    const plist = pd.props || [];
                    for (const prop of plist) {
                        nflProps.push({
                            id: propId++,
                            player_name: p.name,
                            player_team: p.team_name,
                            player_position: p.position,
                            sport: 'NFL',
                            prop_type: (prop.stat || prop.prop_type || '').toLowerCase(),
                            difficulty: prop.type || prop.difficulty || 'MEDIUM',
                            line_value: prop.line || prop.line_value,
                            live_contract_price: prop.price || 50,
                            available_contracts: 10,
                            total_contracts: 10,
                            status_badge: gameStatuses[p.game_id] || 'UPCOMING',
                            is_tradeable: (gameStatuses[p.game_id] || 'UPCOMING') !== 'FINAL',
                            formatted_game_time: data.games.find(g=>g.game_id===p.game_id)?.game_time_et || 'TBD',
                            direction: prop.direction || 'N/A',
                            implied_probability: prop.implied_prob || prop.implied_probability || 52.0,
                            game_id: p.game_id,
                            opponent: null,
                            player_status: p.status || 'ACTIVE',
                            over_hit: false
                        });
                    }
                }

                return nflProps;
            } catch (e) {
                console.error('Failed to load NFL props', e);
                return [];
            }
        }

        // Real MLB props only
        let mockProps = [];

        // Authentication (Demo Mode)
        document.getElementById('login-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            await handleLogin();
        });

        document.getElementById('register-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            await handleRegister();
        });

        async function handleLogin() {
            const username = document.getElementById('login-username').value;
            const password = document.getElementById('login-password').value;
            
            try {
                const response = await fetch(`${API_BASE}/auth/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    currentUser = data.user;
                    showDashboard();
                    showToast('Login successful!', 'success');
                } else {
                    showToast(data.error || 'Login failed', 'error');
                }
            } catch (error) {
                console.error('Login error:', error);
                showToast('Login failed. Please try again.', 'error');
            }
        }

        async function handleRegister() {
            const formData = {
                username: document.getElementById('register-username').value,
                email: document.getElementById('register-email').value,
                password: document.getElementById('register-password').value,
                first_name: document.getElementById('register-first-name').value,
                last_name: document.getElementById('register-last-name').value,
                date_of_birth: document.getElementById('register-date-of-birth').value,
                phone_number: document.getElementById('register-phone').value,
                address: document.getElementById('register-address').value,
                city: document.getElementById('register-city').value,
                state: document.getElementById('register-state').value,
                zip_code: document.getElementById('register-zip').value,
                country: document.getElementById('register-country').value
            };
            
            try {
                const response = await fetch(`${API_BASE}/auth/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    currentUser = data.user;
                    showDashboard();
                    showToast('Registration successful!', 'success');
                } else {
                    showToast(data.error || 'Registration failed', 'error');
                }
            } catch (error) {
                console.error('Registration error:', error);
                showToast('Registration failed. Please try again.', 'error');
            }
        }

        async function showDashboard() {
            document.getElementById('auth-forms').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';
            document.getElementById('username').textContent = currentUser.username;
            
            // Load real props with better error handling
            try {
                console.log('üîÑ Starting to load props...');
                
                // Show loading indicator
                const loadingDiv = document.createElement('div');
                loadingDiv.id = 'loading-indicator';
                loadingDiv.className = 'alert alert-info';
                loadingDiv.innerHTML = 'üîÑ Loading props...';
                document.querySelector('.container').prepend(loadingDiv);
                
                // Load props separately to avoid blocking
                let mlb = [];
                let nfl = [];
                
                try {
                    mlb = await loadRealMLBProps();
                    console.log('‚úÖ MLB props loaded:', mlb.length);
                } catch (error) {
                    console.error('‚ùå Error loading MLB props:', error);
                    mlb = [];
                }
                
                try {
                    nfl = await loadRealNFLProps();
                    console.log('‚úÖ NFL props loaded:', nfl.length);
                } catch (error) {
                    console.error('‚ùå Error loading NFL props:', error);
                    nfl = [];
                }
                
                const realProps = [...mlb, ...nfl];
                console.log('‚úÖ Total props loaded:', realProps.length);
                
                // Remove loading indicator
                const loadingDiv = document.getElementById('loading-indicator');
                if (loadingDiv) {
                    loadingDiv.remove();
                }
                
                // Use the real props for the interface
                window.REAL_PROPS = realProps;
                renderProps(realProps);
                startLiveUpdates();
                
                // Load leaderboard and platform stats
                loadLeaderboard();
                loadPlatformStats();
                
            } catch (error) {
                console.error('‚ùå Error in prop loading:', error);
                
                // Remove loading indicator
                const loadingDiv = document.getElementById('loading-indicator');
                if (loadingDiv) {
                    loadingDiv.remove();
                }
                
                // Show error message to user
                const errorDiv = document.createElement('div');
                errorDiv.className = 'alert alert-danger';
                errorDiv.innerHTML = 'Error loading props. Please refresh the page.';
                document.querySelector('.container').prepend(errorDiv);
            }
         }

        function logout() {
            currentUser = { username: 'Demo User', balance: 10000 };
            userPortfolio = [];
            tradeHistory = [];
            document.getElementById('auth-forms').style.display = 'block';
            document.getElementById('dashboard').style.display = 'none';
            if (liveUpdateInterval) {
                clearInterval(liveUpdateInterval);
            }
        }

        // Market Data
        async function loadMarketData() {
            console.log('üîÑ Loading market data...');
            console.log('üìä Current mockProps:', mockProps);
            console.log('üìä mockProps length:', mockProps.length);
            
            const sportFilter = document.getElementById('sport-filter').value;
            const difficultyFilter = document.getElementById('difficulty-filter').value;
            const statusFilter = document.getElementById('status-filter').value;
            const statCategoryFilter = document.getElementById('stat-category-filter').value;

            // Update props status indicator
            const statusElement = document.getElementById('props-status');
            if (mockProps.length > 0) {
                // Check if we have real game times
                const hasRealTimes = mockProps.some(prop => prop.formatted_game_time && prop.formatted_game_time !== 'TBD');
                if (hasRealTimes) {
                    statusElement.innerHTML = `<i class="fas fa-check-circle text-success"></i> ${mockProps.length} real MLB props loaded with actual game times (sorted by start time)<br><button type="button" class="btn btn-sm btn-outline-primary mt-2" onclick="refreshProps()"><i class="fas fa-sync-alt"></i> Refresh Props</button>`;
                    statusElement.className = 'mt-3 text-center text-success';
                    } else {
                    statusElement.innerHTML = `<i class="fas fa-exclamation-triangle text-warning"></i> ${mockProps.length} props loaded (game times not available)<br><button type="button" class="btn btn-sm btn-outline-primary mt-2" onclick="refreshProps()"><i class="fas fa-sync-alt"></i> Refresh Props</button>`;
                    statusElement.className = 'mt-3 text-center text-warning';
                    }
                } else {
                statusElement.innerHTML = `<i class="fas fa-info-circle text-muted"></i> No props available`;
                statusElement.className = 'mt-3 text-center text-muted';
            }

            let filteredProps = mockProps;
            
            if (sportFilter) {
                filteredProps = filteredProps.filter(prop => prop.sport === sportFilter);
            }
            if (difficultyFilter) {
                filteredProps = filteredProps.filter(prop => prop.difficulty === difficultyFilter);
            }
            if (statusFilter) {
                filteredProps = filteredProps.filter(prop => prop.status_badge === statusFilter);
            }
                         if (statCategoryFilter) {
                             // Filter for specific stat categories
                             filteredProps = filteredProps.filter(prop => 
                                 prop.prop_type.toLowerCase() === statCategoryFilter.toLowerCase()
                             );
                         }

            displayProps(filteredProps, statusFilter);
            
            // Show game schedule
            showGameSchedule();
        }

        // Refresh props function
        async function refreshProps() {
            console.log('üîÑ Manually refreshing props...');
            try {
                const realProps = await loadRealMLBProps();
                mockProps = realProps;
                console.log('‚úÖ Props refreshed successfully');
                loadMarketData(); // Reload the display
            } catch (error) {
                console.error('‚ùå Failed to refresh props:', error);
                alert('Failed to refresh props. Please try again.');
            }
        }

        // Display props in the market
        function displayProps(props, statusFilter) {
            console.log('üéØ Displaying props:', props.length);
            console.log('üìä Sample prop contract counts:', props.slice(0, 3).map(p => `${p.player_name}: ${p.available_contracts}/${p.total_contracts}`));
            
            const container = document.getElementById('props-container');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (props.length === 0) {
                container.innerHTML = '<div class="text-center text-muted mt-4"><i class="fas fa-info-circle"></i> No props match your filters.</div>';
                return;
            }
            
            props.forEach(prop => {
                // Apply status filter
                if (statusFilter && prop.status_badge !== statusFilter) {
                    return;
                }

                const card = document.createElement('div');
                card.className = 'trading-card';
                
                const statusClass = prop.status_badge === 'LIVE' ? 'status-live' : 
                                  prop.status_badge === 'FINAL' ? 'status-final' : 
                                  prop.status_badge === 'CANCELLED' ? 'status-cancelled' :
                                  prop.status_badge === 'RULED_OUT' ? 'status-ruled-out' :
                                  prop.status_badge === 'OVER_HIT' ? 'status-over-hit' :
                                  prop.status_badge === 'PUSH' ? 'status-push' : 'status-upcoming';

                const formatPropType = (propType) => {
                    return propType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                };

                // Determine if trading is available
                const isTradingAvailable = prop.is_tradeable && prop.available_contracts > 0;
                const tradingDisabled = !isTradingAvailable ? 'disabled' : '';

            card.innerHTML = `
                        <div class="row">
                        <div class="col-md-8">
                            <div class="d-flex justify-content-between align-items-start mb-2">
                                <div>
                                    <h6 class="mb-0">${prop.player_name} (${prop.player_team})</h6>
                                    <small class="text-muted">
                                        ${prop.player_position || ''} ‚Ä¢ <strong class="text-primary"><i class="fas fa-clock"></i> ${prop.formatted_game_time || 'TBD'}</strong>
                                    </small>
                                    ${prop.opponent ? `<br><small class="text-info"><i class="fas fa-gamepad"></i> ${prop.opponent}</small>` : ''}
                            </div>
                                <span class="status-badge ${statusClass}">${prop.status_badge}</span>
                            </div>
                            <p class="text-muted mb-2">${prop.sport} ‚Ä¢ ${formatPropType(prop.prop_type)} ‚Ä¢ ${prop.difficulty}</p>
                            
                            ${prop.status_badge === 'LIVE' ? `
                                <div class="game-info">
                                    <small><strong>Game Status:</strong> <span class="text-danger">LIVE - Trading Closed</span></small><br>
                                    <small><strong>Note:</strong> Game is in progress, contracts can be cashed out when final</small>
                        </div>
                            ` : ''}
                            
                            ${prop.status_badge === 'FINAL' ? `
                                <div class="game-info">
                                    <small><strong>Game Status:</strong> <span class="text-secondary">FINAL</span></small><br>
                                    <small><strong>Action:</strong> Cash out your contracts to collect winnings!</small>
                        </div>
                            ` : ''}
                            
                            ${prop.status_badge === 'CANCELLED' ? `
                                <div class="game-info">
                                    <small><strong>Game Status:</strong> <span class="text-warning">CANCELLED/POSTPONED</span></small><br>
                                    <small><strong>Action:</strong> Contracts automatically refunded at purchase price</small>
                    </div>
                            ` : ''}
                            
                            ${prop.status_badge === 'RULED_OUT' ? `
                                <div class="game-info">
                                    <small><strong>Player Status:</strong> <span class="text-danger">RULED OUT - NOT PLAYING</span></small><br>
                                    <small><strong>Action:</strong> All contracts automatically refunded at purchase price</small>
                </div>
                            ` : ''}
                            
                            ${prop.status_badge === 'OVER_HIT' ? `
                                <div class="game-info">
                                    <small><strong>Prop Status:</strong> <span class="text-success">OVER TARGET HIT! üéØ</span></small><br>
                                    <small><strong>Action:</strong> All over contracts automatically cashed out at full value</small>
                                </div>
                            ` : ''}
                            ${prop.status_badge === 'PUSH' ? `
                                <div class="game-info">
                                    <small><strong>Prop Status:</strong> <span class="text-primary">PUSH (Exact on the line)</span></small><br>
                                    <small><strong>Action:</strong> Your stake is refunded in full.</small>
                                </div>
                            ` : ''}
                            
                            <div class="player-stats">
                                <strong>Line:</strong> ${prop.line_value} | 
                                <strong>Current Price:</strong> <span class="live-price">${prop.live_contract_price.toFixed(2)}</span>
                                <br><small class="${prop.available_contracts <= 5 ? 'text-danger' : prop.available_contracts <= 15 ? 'text-warning' : 'text-muted'}">
                                    Contracts: ${prop.available_contracts}/${prop.total_contracts} available
                                    ${prop.available_contracts <= 5 ? ' ‚ö†Ô∏è LOW' : prop.available_contracts <= 15 ? ' ‚ö° FEW LEFT' : ''}
                                </small>
                            </div>
                        </div>
                        <div class="col-md-4">
                            ${(() => {
                                if (prop.status_badge === 'CANCELLED') {
                                    return '<div class="text-warning"><i class="fas fa-exclamation-triangle"></i> Game Cancelled</div>';
                                }
                                
                                if (prop.status_badge === 'RULED_OUT') {
                                    return '<div class="text-danger"><i class="fas fa-user-times"></i> Player Ruled Out</div>';
                                }
                                
                                if (prop.status_badge === 'OVER_HIT') {
                                    return '<div class="text-success"><i class="fas fa-trophy"></i> Over Target Hit!</div>';
                                }
                                
                                if (prop.status_badge === 'FINAL') {
                                    return '<button class="btn btn-warning btn-trade w-100" onclick="openTradingModal(' + prop.id + ', \'cashout\')"><i class="fas fa-trophy"></i> Cash Out</button>';
                                }
                                
                                if (!prop.is_tradeable) {
                                    return '<div class="text-muted">Trading Closed</div>';
                                }
            
            let tradingOptions = '';
            const isAvailable = prop.available_contracts > 0;
                                const disabledAttr = isAvailable ? '' : 'disabled';
            
                                // Use the actual prop direction from scraper data
            const propDirection = prop.direction || 'over';
            const buttonText = propDirection.toUpperCase() + ' ' + prop.line_value;
            
            if (prop.difficulty === 'EASY' || prop.difficulty === 'HARD') {
                // Single direction for easy/hard props
                                    const buttonColor = isAvailable ? 'btn-success' : 'btn-secondary';
                tradingOptions = `
                                        <button class="btn ${buttonColor} btn-trade w-100 mb-2" onclick="openTradingModal(${prop.id}, '${propDirection}')" ${disabledAttr}>
                                            ${isAvailable ? buttonText : 'NO CONTRACTS'}
                    </button>
                `;
            } else if (prop.difficulty === 'MEDIUM') {
                // Both directions for medium props
                                    const overColor = isAvailable ? 'btn-success' : 'btn-secondary';
                                    const underColor = isAvailable ? 'btn-danger' : 'btn-secondary';
                
                tradingOptions = `
                                        <button class="btn ${overColor} btn-trade w-100 mb-2" onclick="openTradingModal(${prop.id}, 'over')" ${disabledAttr}>
                                            ${isAvailable ? `OVER ${prop.line_value}` : 'NO CONTRACTS'}
                    </button>
                                        <button class="btn ${underColor} btn-trade w-100 mb-2" onclick="openTradingModal(${prop.id}, 'under')" ${disabledAttr}>
                                            ${isAvailable ? `UNDER ${prop.line_value}` : 'NO CONTRACTS'}
                    </button>
                `;
            }
            return tradingOptions;
                            })()}
                        </div>
                    </div>
                `;
                
                container.appendChild(card);
            });
        }

        // Trading
        function openTradingModal(propId, type) {
            console.log('Opening trading modal for prop:', propId, 'type:', type);
            
            const prop = mockProps.find(p => p.id === propId);
            if (!prop) {
                console.error('Prop not found:', propId);
                return;
            }

            // Handle cash out for final games
            if (type === 'cashout') {
                handleCashOut(propId);
                return;
            }

            // Check if contracts are available
            if (prop.available_contracts <= 0) {
                alert('No contracts available for this player!');
                return;
            }

            // Check if modal element exists
            const modalElement = document.getElementById('tradingModal');
            if (!modalElement) {
                console.error('Trading modal element not found!');
                alert('Trading modal not found. Please refresh the page.');
                return;
            }

            try {
                document.getElementById('tradingModalTitle').textContent = `Trade ${prop.player_name} Contract`;
                
                // Update trading details
                document.getElementById('trading-details').innerHTML = `
                    <div class="row">
                        <div class="col-md-6">
                            <p><strong>Player:</strong> ${prop.player_name} (${prop.player_team})</p>
                            <p><strong>Prop:</strong> ${prop.prop_type.replace(/_/g, ' ').toUpperCase()} ${type.toUpperCase()} ${prop.line_value}</p>
                            <p><strong>Sport:</strong> ${prop.sport} ‚Ä¢ <strong>Difficulty:</strong> ${prop.difficulty}</p>
                        </div>
                        <div class="col-md-6">
                            <p><strong>Available Contracts:</strong> ${prop.available_contracts}/${prop.total_contracts}</p>
                            <p><strong>Current Portfolio:</strong> ${userPortfolio.length}/10 contracts</p>
                            <p><strong>Available Balance:</strong> $${currentUser.balance.toFixed(2)}</p>
                            <p><strong>Game Status:</strong> <span class="badge bg-${getStatusColor(prop.status_badge)}">${prop.status_badge}</span></p>
                        </div>
                    </div>
                `;
                
                // Update market price and available contracts
                const marketPrice = getMarketPrice(propId);
                document.getElementById('current-market-price').textContent = `$${marketPrice.toFixed(2)}`;
                document.getElementById('available-contracts').textContent = prop.available_contracts;
                
                // Update trading options based on game status
                updateTradingOptions(prop);
                
                // Clear previous input values
                document.getElementById('buy-limit-price').value = '';
                document.getElementById('sell-limit-price').value = '';
                
                window.currentTradingProp = { id: propId, type: type, prop: prop };
                
                console.log('Showing modal...');
                const modal = new bootstrap.Modal(modalElement);
                modal.show();
                console.log('Modal should be visible now');
                
            } catch (error) {
                console.error('Error opening trading modal:', error);
                alert('Error opening trading modal: ' + error.message);
            }
        }

        function updateTradingOptions(prop) {
            const buyOptions = document.getElementById('buy-options');
            const sellOptions = document.getElementById('sell-options');

            // Clear existing options
            buyOptions.innerHTML = '';
            sellOptions.innerHTML = '';

            // Determine if trading is available
            const isTradingAvailable = prop.is_tradeable && prop.available_contracts > 0;
            const buyButtonText = isTradingAvailable ? `Buy at Market Price` : `NO CONTRACTS`;
            const buyButtonColor = isTradingAvailable ? 'btn-success' : 'btn-secondary';

            const sellButtonText = isTradingAvailable ? `Sell at Market Price` : `NO CONTRACTS`;
            const sellButtonColor = isTradingAvailable ? 'btn-danger' : 'btn-secondary';

            // Add Buy Options
            buyOptions.innerHTML = `
                <div class="mb-3">
                    <label class="form-label">Buy Now (Market Price)</label>
                    <button type="button" class="btn ${buyButtonColor} w-100" onclick="executeTrade('buy', 'market')">
                        ${buyButtonText}
                    </button>
                </div>
                <div class="mb-3">
                    <label class="form-label">Limit Buy Order</label>
                    <div class="input-group">
                        <span class="input-group-text">$</span>
                        <input type="number" class="form-control" id="buy-limit-price" placeholder="0.00" step="0.01" min="0.01" max="99.99">
                    </div>
                    <button type="button" class="btn btn-outline-success w-100 mt-2" onclick="executeTrade('buy', 'limit')">
                        Place Buy Order
                    </button>
                </div>
            `;

            // Add Sell Options
            sellOptions.innerHTML = `
                <div class="mb-3">
                    <label class="form-label">Sell Now (Market Price)</label>
                    <button type="button" class="btn ${sellButtonColor} w-100" onclick="executeTrade('sell', 'market')">
                        ${sellButtonText}
                    </button>
                </div>
                <div class="mb-3">
                    <label class="form-label">Limit Sell Order</label>
                    <div class="input-group">
                        <span class="input-group-text">$</span>
                        <input type="number" class="form-control" id="sell-limit-price" placeholder="0.00" step="0.01" min="0.01" max="99.99">
                    </div>
                    <button type="button" class="btn btn-outline-danger w-100 mt-2" onclick="executeTrade('sell', 'limit')">
                        Place Sell Order
                    </button>
                </div>
            `;

            // Show/hide cash out section
            const cashOutSection = document.getElementById('cash-out-section');
            if (prop.status_badge === 'FINAL') {
                cashOutSection.style.display = 'block';
            } else {
                cashOutSection.style.display = 'none';
            }
        }

        function getStatusColor(status) {
            switch (status) {
                case 'LIVE':
                    return 'danger';
                case 'FINAL':
                    return 'secondary';
                case 'UPCOMING':
                default:
                    return 'success';
            }
        }
        
        // Handle live game transitions
        function handleGameStatusChange(prop) {
            if (prop.status_badge === 'LIVE') {
                // When game goes live, any unsold contracts vanish from market
                if (prop.available_contracts > 0) {
                    console.log(`Game ${prop.id} is now LIVE - ${prop.available_contracts} unsold contracts vanished from market`);
                    prop.available_contracts = 0;
                }
            }
            
            // Update trading options if modal is open
            if (window.currentTradingProp && window.currentTradingProp.prop.id === prop.id) {
                updateTradingOptions(prop);
            }
        }

        // New executeTrade function for order book system
        async function executeTrade(action, orderType = 'market') {
            const quantity = 1; // Fixed to 1 contract per player
            const tradingProp = window.currentTradingProp;
            
            if (!tradingProp) return;

            const prop = tradingProp.prop;
            
            if (action === 'buy') {
                // Check portfolio limit (including pending buy orders)
                const totalPortfolioContracts = userPortfolio.length;
                const totalPendingBuyContracts = pendingOrders.filter(order => 
                    order.side === 'buy' && order.status === 'pending'
                ).length;
                const totalContracts = totalPortfolioContracts + totalPendingBuyContracts;
                
                if (totalContracts >= 10) {
                    alert(`Portfolio limit reached! Maximum 10 contracts allowed (${totalPortfolioContracts} owned + ${totalPendingBuyContracts} pending = ${totalContracts}/10).`);
                    return;
                }
                
                // Check if user already owns ANY contract for this player (regardless of prop type)
                if (!checkPlayerContractLimit(prop)) {
                    return;
                }
                
                // Check team concentration constraint (max 50% from same team)
                if (!checkTeamConcentrationConstraint(prop.player_team)) {
                    alert('Team concentration limit reached! No more than 50% of your contracts can be from the same team.');
                    return;
                }
                
                if (orderType === 'market') {
                    // Market buy - execute immediately
                    const marketPrice = getMarketPrice(prop.id);
                    const totalCost = marketPrice;
                    
                    if (currentUser.balance < totalCost) {
                        alert('Insufficient balance!');
                        return;
                    }
                    
                    // Check if contracts are available
                    if (prop.available_contracts <= 0) {
                        alert('No contracts available for this player!');
                        return;
                    }
                    
                    currentUser.balance -= totalCost;
                    
                    // Update the mockProps array so the change persists
                    const mockProp = mockProps.find(p => p.id === prop.id);
                    if (mockProp) {
                        mockProp.available_contracts -= 1;
                    }
                    
                    // Add to portfolio
                    userPortfolio.push({
                        prop_id: prop.id,
                        player_name: prop.player_name,
                        prop_type: prop.prop_type,
                        trade_type: tradingProp.type,
                        team_name: prop.player_team,
                        quantity: 1,
                        avg_price: marketPrice,
                        live_price: marketPrice,
                        game_status: prop.status_badge
                    });
                    
                    // Record trade
                    recordTrade('BUY', prop, marketPrice, 'market');
                    
                } else if (orderType === 'limit') {
                    // Limit buy order
                    const limitPrice = parseFloat(document.getElementById('buy-limit-price').value);
                    
                    if (!limitPrice || limitPrice <= 0 || limitPrice > 99.99) {
                        alert('Please enter a valid price between $0.01 and $99.99');
                        return;
                    }
                    
                    const marketPrice = getMarketPrice(prop.id);
                    
                    // If buy price is above market price, execute immediately at market price
                    if (limitPrice >= marketPrice) {
                        if (currentUser.balance < marketPrice) {
                            alert('Insufficient balance!');
                            return;
                        }
                        
                        if (prop.available_contracts <= 0) {
                            alert('No contracts available for this player!');
                            return;
                        }
                        
                        // Execute immediately at market price
                        currentUser.balance -= marketPrice;
                        
                        // Update the mockProps array so the change persists
                        const mockProp = mockProps.find(p => p.id === prop.id);
                        if (mockProp) {
                            mockProp.available_contracts -= 1;
                        }
                        
                        // Cancel any pending buy orders for this contract
                        cancelPendingBuyOrders(prop.id, tradingProp.type);
                        
                        // Add to portfolio
                        userPortfolio.push({
                            prop_id: prop.id,
                            player_name: prop.player_name,
                            prop_type: prop.prop_type,
                            trade_type: tradingProp.type,
                            team_name: prop.player_team,
                            quantity: 1,
                            avg_price: marketPrice,
                            live_price: marketPrice,
                            game_status: prop.status_badge
                        });
                        
                        // Record trade
                        recordTrade('BUY', prop, marketPrice, 'limit_auto_execute');
                        
                        alert(`Buy order executed immediately at market price $${marketPrice.toFixed(2)} (your limit $${limitPrice.toFixed(2)} was above market)`);
                    } else {
                        // Place pending buy order below market
                        if (currentUser.balance < limitPrice) {
                            alert('Insufficient balance for limit order!');
                            return;
                        }
                        
                        // Create pending buy order
                        const order = {
                            id: Date.now(),
                            prop_id: prop.id,
                            player_name: prop.player_name,
                            prop_type: prop.prop_type,
                            trade_type: tradingProp.type,
                            team_name: prop.player_team,
                            side: 'buy',
                            price: limitPrice,
                            quantity: 1,
                            timestamp: new Date().toLocaleString(),
                            status: 'pending'
                        };
                        
                        pendingOrders.push(order);
                        currentUser.balance -= limitPrice; // Reserve the funds
                        
                        alert(`Buy order placed at $${limitPrice.toFixed(2)}. Funds reserved.`);
                    }
                }
                
            } else if (action === 'sell') {
                if (orderType === 'market') {
                    // Market sell - execute immediately
                    const position = userPortfolio.find(p => 
                        p.prop_id === prop.id && p.trade_type === tradingProp.type
                    );
                    
                    if (!position) {
                        alert('You don\'t own this contract!');
                        return;
                    }
                    
                    const marketPrice = getMarketPrice(prop.id);
                    currentUser.balance += marketPrice;
                    
                    // Update the mockProps array so the change persists
                    const mockProp = mockProps.find(p => p.id === prop.id);
                    if (mockProp) {
                        mockProp.available_contracts += 1;
                    }
                    
                    // Remove from portfolio
                    userPortfolio = userPortfolio.filter(p => p !== position);
                    
                    // Cancel any pending sell orders for this contract
                    cancelPendingSellOrders(prop.id, tradingProp.type);
                    
                    // Record trade
                    recordTrade('SELL', prop, marketPrice, 'market');
                    
                } else if (orderType === 'limit') {
                    // Limit sell order
                    const limitPrice = parseFloat(document.getElementById('sell-limit-price').value);
                    
                    if (!limitPrice || limitPrice <= 0 || limitPrice > 99.99) {
                        alert('Please enter a valid price between $0.01 and $99.99');
                        return;
                    }
                    
                    const position = userPortfolio.find(p => 
                        p.prop_id === prop.id && p.trade_type === tradingProp.type
                    );
                    
                    if (!position) {
                        alert('You don\'t own this contract!');
                        return;
                    }
                    
                    const marketPrice = getMarketPrice(prop.id);
                    
                    // If sell price is below market price, execute immediately at market price
                    if (limitPrice <= marketPrice) {
                        // Execute immediately at market price
                        currentUser.balance += marketPrice;
                        
                        // Update the mockProps array so the change persists
                        const mockProp = mockProps.find(p => p.id === prop.id);
                        if (mockProp) {
                            mockProp.available_contracts += 1;
                        }
                        
                        // Remove from portfolio
                        userPortfolio = userPortfolio.filter(p => p !== position);
                        
                        // Cancel any pending sell orders for this contract
                        cancelPendingSellOrders(prop.id, tradingProp.type);
                        
                        // Record trade
                        recordTrade('SELL', prop, marketPrice, 'limit_auto_execute');
                        
                        alert(`Sell order executed immediately at market price $${marketPrice.toFixed(2)} (your limit $${limitPrice.toFixed(2)} was below market)`);
                    } else {
                        // Place pending sell order above market
                        const order = {
                            id: Date.now(),
                            prop_id: prop.id,
                            player_name: prop.player_name,
                            prop_type: prop.prop_type,
                            trade_type: tradingProp.type,
                            team_name: prop.player_team,
                            side: 'sell',
                            price: limitPrice,
                            quantity: 1,
                            timestamp: new Date().toLocaleString(),
                            status: 'pending'
                        };
                        
                        // Debug: Log the order and prop to console
                        console.log('Creating sell order:', order);
                        console.log('Prop object:', prop);
                        console.log('Team name from prop:', prop.player_team);
                        
                        pendingOrders.push(order);
                        
                        alert(`Sell order placed at $${limitPrice.toFixed(2)}.`);
                    }
                }
            }
            
            // Refresh displays
            loadMarketData();
            loadPortfolio();
            loadPendingOrders();
            loadTradeHistory();
            
            if (orderType === 'market') {
                bootstrap.Modal.getInstance(document.getElementById('tradingModal')).hide();
            }
        }

        // Helper functions for new trading system
        function getMarketPrice(propId) {
            const prop = mockProps.find(p => p.id === propId);
            if (!prop) return prop.live_contract_price;
            
            // Get all pending orders for this prop
            const buyOrders = pendingOrders.filter(o => o.prop_id === propId && o.side === 'buy' && o.status === 'pending');
            const sellOrders = pendingOrders.filter(o => o.prop_id === propId && o.side === 'sell' && o.status === 'pending');
            
            if (buyOrders.length > 0 && sellOrders.length > 0) {
                // Calculate average of buy and sell prices
                const avgBuyPrice = buyOrders.reduce((sum, order) => sum + order.price, 0) / buyOrders.length;
                const avgSellPrice = sellOrders.reduce((sum, order) => sum + order.price, 0) / sellOrders.length;
                return Math.round((avgBuyPrice + avgSellPrice) / 2 * 100) / 100;
            }
            
            // Fallback to implied prop price
            return prop.live_contract_price;
        }

        // Constraint validation functions
        function checkPlayerContractLimit(prop) {
            // Check portfolio
            const existingContract = userPortfolio.find(p => p.player_name === prop.player_name);
            if (existingContract) {
                alert(`You already own a contract for ${prop.player_name}. Maximum 1 contract per player (any prop type).`);
                return false;
            }
            
            // Check pending buy orders
            const existingPendingBuy = pendingOrders.find(order => 
                order.player_name === prop.player_name && 
                order.side === 'buy' && 
                order.status === 'pending'
            );
            if (existingPendingBuy) {
                alert(`You already have a pending buy order for ${prop.player_name}. Maximum 1 contract per player (any prop type).`);
                return false;
            }
            
            return true;
        }
        
        function checkTeamConcentrationConstraint(teamName) {
            // Calculate total contracts (portfolio + pending buy orders)
            const totalPortfolioContracts = userPortfolio.length;
            const totalPendingBuyContracts = pendingOrders.filter(order => 
                order.side === 'buy' && order.status === 'pending'
            ).length;
            const totalContracts = totalPortfolioContracts + totalPendingBuyContracts;
            
            if (totalContracts === 0) return true; // No constraints until first contract
            
            const maxTeamContracts = Math.ceil(totalContracts * 0.5);
            
            // Count team contracts from portfolio
            const portfolioTeamContracts = userPortfolio.filter(p => p.team_name === teamName).length;
            
            // Count team contracts from pending buy orders
            const pendingTeamContracts = pendingOrders.filter(order => 
                order.team_name === teamName && 
                order.side === 'buy' && 
                order.status === 'pending'
            ).length;
            
            const totalTeamContracts = portfolioTeamContracts + pendingTeamContracts;
            
            if (totalTeamContracts >= maxTeamContracts) {
                alert(`Team concentration limit reached. You can only have ${maxTeamContracts} contracts from ${teamName} (50% of ${totalContracts} total contracts).`);
                return false;
            }
            
            return true;
        }


        function recordTrade(action, prop, price, orderType) {
            tradeHistory.unshift({
                player_name: prop.player_name,
                prop_type: prop.prop_type,
                trade_type: prop.trade_type || 'over',
                team_name: prop.team_name,
                action: action,
                quantity: 1,
                price: price,
                orderType: orderType,
                timestamp: new Date().toLocaleString()
            });
            
            // Keep only last 50 trades
            if (tradeHistory.length > 50) {
                tradeHistory = tradeHistory.slice(0, 50);
            }
        }

        function loadPendingOrders() {
            displayPendingOrders(pendingOrders);
        }

        function displayPendingOrders(orders) {
            const container = document.getElementById('pending-orders');
            container.innerHTML = '';

            if (orders.length === 0) {
                container.innerHTML = '<p class="text-muted">No pending orders</p>';
                return;
            }

            orders.forEach(order => {
                // Try to find team name from portfolio if missing
                let teamName = order.team_name;
                if (!teamName || teamName === 'Unknown Team') {
                    const portfolioItem = userPortfolio.find(p => 
                        p.player_name === order.player_name && 
                        p.prop_type === order.prop_type
                    );
                    if (portfolioItem && portfolioItem.team_name) {
                        teamName = portfolioItem.team_name;
                        // Update the order with the found team name
                        order.team_name = teamName;
                    }
                }
                
                const div = document.createElement('div');
                div.className = 'pending-order-item';
                div.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <strong>${order.player_name}</strong><br>
                            <small>${order.prop_type.toUpperCase()} ${order.side.toUpperCase()} @ $${order.price.toFixed(2)}</small><br>
                            <small class="text-muted">${teamName || 'Unknown Team'}</small>
                        </div>
                        <div class="text-end">
                            <small class="text-muted">${order.timestamp}</small><br>
                            <button class="btn btn-sm btn-outline-danger" onclick="cancelOrder(${order.id})">
                                <i class="fas fa-times"></i> Cancel
                            </button>
                        </div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function cancelOrder(orderId) {
            const order = pendingOrders.find(o => o.id === orderId);
            if (!order) return;
            
            if (order.side === 'buy') {
                // Refund the reserved funds
                currentUser.balance += order.price;
            }
            
            // Remove from pending orders
            pendingOrders = pendingOrders.filter(o => o.id !== orderId);
            
            alert(`Order cancelled. ${order.side === 'buy' ? 'Funds refunded.' : ''}`);
            
            loadPendingOrders();
            loadPortfolio();
        }

        // Portfolio
        async function loadPortfolio() {
            document.getElementById('user-balance').textContent = `${currentUser.balance.toFixed(2)}`;
            displayPortfolio(userPortfolio);
        }

        function displayPortfolio(portfolio) {
            const container = document.getElementById('portfolio-items');
            container.innerHTML = '';

            if (portfolio.length === 0) {
                container.innerHTML = '<p class="text-muted">No active positions</p>';
                return;
            }

            // Add team concentration warning at the top
            const teamCounts = {};
            portfolio.forEach(item => {
                const team = item.team_name || 'Unknown Team';
                teamCounts[team] = (teamCounts[team] || 0) + 1;
            });

            // Only show warning if portfolio has contracts
            if (portfolio.length > 0) {
                const maxTeamContracts = Math.ceil(portfolio.length * 0.5);
                const concentrationWarning = Object.entries(teamCounts)
                    .filter(([team, count]) => count > maxTeamContracts)
                    .map(([team, count]) => `${team}: ${count}/${portfolio.length}`)
                    .join(', ');

                if (concentrationWarning) {
                    const warningDiv = document.createElement('div');
                    warningDiv.className = 'alert alert-warning mb-3';
                    warningDiv.innerHTML = `
                        <i class="fas fa-exclamation-triangle"></i>
                        <strong>Team Concentration Warning:</strong> ${concentrationWarning} exceeds 50% limit
                    `;
                    container.appendChild(warningDiv);
                }
            }

            portfolio.forEach(item => {
                const profitLoss = (item.live_price - item.avg_price) * item.quantity;
                const profitLossClass = profitLoss >= 0 ? 'text-success' : 'text-danger';
                const profitLossIcon = profitLoss >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';

                const div = document.createElement('div');
                div.className = 'portfolio-item';
                div.innerHTML = `
                    <div class="d-flex justify-content-between">
                        <div>
                            <strong>${item.player_name}</strong><br>
                            <small>${item.prop_type.toUpperCase()} ${item.trade_type.toUpperCase()}</small><br>
                            <small class="text-muted">${item.team_name || 'Unknown Team'}</small>
                        </div>
                        <div class="text-end">
                            <div>Qty: 1</div>
                            <div class="live-price">${item.live_price.toFixed(2)}</div>
                            <div class="${profitLossClass}">
                                <i class="fas ${profitLossIcon}"></i> ${Math.abs(profitLoss).toFixed(2)}
                            </div>
                        </div>
                    </div>
                    <div class="d-flex justify-content-between align-items-center mt-2">
                        ${item.game_status === 'LIVE' ? `
                            <small class="text-danger">LIVE</small>
                        ` : '<small class="text-muted">UPCOMING</small>'}
                        <button class="btn btn-sm btn-outline-primary" onclick="openPortfolioTrade('${item.player_name}', '${item.prop_type}', '${item.trade_type}', '${item.team_name}')">
                            <i class="fas fa-trade"></i> Trade
                        </button>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        // Trade History
        async function loadTradeHistory() {
            displayTradeHistory(tradeHistory);
        }

        function displayTradeHistory(trades) {
            const container = document.getElementById('trade-history');
            container.innerHTML = '';

            if (trades.length === 0) {
                container.innerHTML = '<p class="text-muted">No trades yet</p>';
                return;
            }

            trades.forEach(trade => {
                const div = document.createElement('div');
                div.className = `trade-item ${trade.action === 'SELL' ? 'trade-sell' : ''}`;
                div.innerHTML = `
                    <div class="d-flex justify-content-between">
                        <div>
                            <strong>${trade.player_name}</strong><br>
                            <small>${trade.prop_type.toUpperCase()} ${trade.trade_type.toUpperCase()}</small><br>
                            <small class="text-muted">${trade.team_name || 'Unknown Team'}</small>
                        </div>
                        <div class="text-end">
                            <div class="${trade.action === 'BUY' ? 'text-success' : 'text-danger'}">
                                ${trade.action} 1
                            </div>
                            <small>${trade.price.toFixed(2)}</small>
                        </div>
                    </div>
                    <small class="text-muted">${trade.timestamp}</small>
                `;
                container.appendChild(div);
            });
        }

        // Live Updates (Demo)
        function startLiveUpdates() {
            if (liveUpdateInterval) {
                clearInterval(liveUpdateInterval);
            }
            
            liveUpdateInterval = setInterval(() => {
                // Simulate price changes
                mockProps.forEach(prop => {
                    const change = (Math.random() - 0.5) * 2; // -1 to +1
                    prop.live_contract_price = Math.max(1, Math.min(99, prop.live_contract_price + change));
                });
                
                // Update portfolio live prices
                userPortfolio.forEach(position => {
                    const prop = mockProps.find(p => p.id === position.prop_id);
                    if (prop) {
                        position.live_price = prop.live_contract_price;
                    }
                });
                
                // Check for cancelled games and process refunds
                checkForCancelledGames();
                
                // Check for ruled out players and process refunds
                checkForRuledOutPlayers();
                
                // Check for over hit props and process cash outs
                checkForOverHitProps();
                // Check for pushes (exact on the line) and refund stakes
                checkForPushes();
                
                loadMarketData();
                loadPortfolio();
            }, 10000); // Update every 10 seconds
            
            // Add separate interval for game status updates (more frequent)
            if (window.gameStatusInterval) {
                clearInterval(window.gameStatusInterval);
            }
            
            window.gameStatusInterval = setInterval(() => {
                refreshGameStatuses();
            }, 5000); // Refresh game statuses every 5 seconds
        }

        // Open trade modal for portfolio contract
        function openPortfolioTrade(playerName, propType, tradeType, teamName) {
            // Find the portfolio item
            const portfolioItem = userPortfolio.find(p => 
                p.player_name === playerName && 
                p.prop_type === propType && 
                p.trade_type === tradeType
            );
            
            if (!portfolioItem) {
                alert('Portfolio item not found');
                return;
            }
            
            // Create a mock prop object for the trading modal
            const mockProp = {
                id: portfolioItem.prop_id,
                player_name: portfolioItem.player_name,
                prop_type: portfolioItem.prop_type,
                trade_type: portfolioItem.trade_type,
                team_name: portfolioItem.team_name,
                live_contract_price: portfolioItem.live_price,
                available_contracts: 1,
                total_contracts: 1,
                status_badge: portfolioItem.game_status,
                is_tradeable: true
            };
            
            // Set the current trading prop
            window.currentTradingProp = {
                prop: mockProp,
                type: tradeType
            };
            
            // Update the modal title
            document.getElementById('tradingModalTitle').textContent = `Trade ${playerName} - ${propType.toUpperCase()} ${tradeType.toUpperCase()}`;
            
            // Show the modal
            const tradingModal = new bootstrap.Modal(document.getElementById('tradingModal'));
            tradingModal.show();
            
            // Update the sell options to show current portfolio info
            updateSellOptions(portfolioItem);
        }
        
        // Cancel pending sell orders for a specific contract
        function cancelPendingSellOrders(propId, tradeType) {
            // Find and remove all pending sell orders for this contract
            const ordersToCancel = pendingOrders.filter(order => 
                order.prop_id === propId && 
                order.trade_type === tradeType && 
                order.side === 'sell' && 
                order.status === 'pending'
            );
            
            if (ordersToCancel.length > 0) {
                console.log(`Cancelling ${ordersToCancel.length} pending sell orders for contract ${propId}`);
                
                // Remove the cancelled orders
                pendingOrders = pendingOrders.filter(order => 
                    !(order.prop_id === propId && 
                      order.trade_type === tradeType && 
                      order.side === 'sell' && 
                      order.status === 'pending')
                );
                
                // Update the display
                loadPendingOrders();
            }
        }
        
        // Cancel pending buy orders for a specific contract
        function cancelPendingBuyOrders(propId, tradeType) {
            // Find and remove all pending buy orders for this contract
            const ordersToCancel = pendingOrders.filter(order => 
                order.prop_id === propId && 
                order.trade_type === tradeType && 
                order.side === 'buy' && 
                order.status === 'pending'
            );
            
            if (ordersToCancel.length > 0) {
                console.log(`Cancelling ${ordersToCancel.length} pending buy orders for contract ${propId}`);
                
                // Remove the cancelled orders
                pendingOrders = pendingOrders.filter(order => 
                    !(order.prop_id === propId && 
                      order.trade_type === tradeType && 
                      order.side === 'buy' && 
                      order.status === 'pending')
                );
                
                // Update the display
                loadPendingOrders();
            }
        }
        
        // Update sell options for portfolio trading
        function updateSellOptions(portfolioItem) {
            // Update trading details section
            document.getElementById('trading-details').innerHTML = `
                <div class="row">
                    <div class="col-md-6">
                        <p><strong>Player:</strong> ${portfolioItem.player_name} (${portfolioItem.team_name})</p>
                        <p><strong>Prop:</strong> ${portfolioItem.prop_type.replace(/_/g, ' ').toUpperCase()} ${portfolioItem.trade_type.toUpperCase()}</p>
                        <p><strong>Current Position:</strong> ${portfolioItem.quantity} contract(s)</p>
                    </div>
                    <div class="col-md-6">
                        <p><strong>Entry Price:</strong> $${portfolioItem.avg_price.toFixed(2)}</p>
                        <p><strong>Current Price:</strong> $${portfolioItem.live_price.toFixed(2)}</p>
                        <p><strong>P&L:</strong> $${((portfolioItem.live_price - portfolioItem.avg_price) * portfolioItem.quantity).toFixed(2)}</p>
                        <p><strong>Game Status:</strong> <span class="badge bg-${getStatusColor(portfolioItem.game_status)}">${portfolioItem.game_status}</span></p>
                    </div>
                </div>
            `;
            
            // Update market price display
            document.getElementById('current-market-price').textContent = `$${portfolioItem.live_price.toFixed(2)}`;
            document.getElementById('available-contracts').textContent = portfolioItem.quantity;
            
            // Update sell options
            const sellOptions = document.getElementById('sell-options');
            sellOptions.innerHTML = `
                <div class="mb-3">
                    <label class="form-label">Sell Now (Market Price)</label>
                    <button type="button" class="btn btn-danger w-100" onclick="executeTrade('sell', 'market')">
                        Sell Now (Market Price)
                    </button>
                </div>
                <div class="mb-3">
                    <label class="form-label">Limit Sell Order</label>
                    <div class="input-group">
                        <span class="input-group-text">$</span>
                        <input type="number" class="form-control" id="sell-limit-price" placeholder="${portfolioItem.live_price.toFixed(2)}" step="0.01" min="0.01" max="99.99">
                    </div>
                    <button type="button" class="btn btn-outline-danger w-100 mt-2" onclick="executeTrade('sell', 'limit')">
                        Place Sell Order
                    </button>
                </div>
            `;
            
            // Clear buy options since this is portfolio trading (selling only)
            const buyOptions = document.getElementById('buy-options');
            buyOptions.innerHTML = `
                <div class="alert alert-info">
                    <i class="fas fa-info-circle"></i> Portfolio Trading Mode - You can only sell contracts you own
                </div>
            `;
        }

        // Cash Out Contract
        function cashOutContract() {
            const tradingProp = window.currentTradingProp;
            if (!tradingProp) return;

            const prop = tradingProp.prop;
            const position = userPortfolio.find(p => 
                p.prop_id === prop.id && p.trade_type === tradingProp.type
            );

            if (!position) {
                alert('You don\'t own this contract!');
                return;
            }

            const marketPrice = getMarketPrice(prop.id);
            const profitLoss = (marketPrice - position.avg_price) * position.quantity;
            const profitLossClass = profitLoss >= 0 ? 'text-success' : 'text-danger';
            const profitLossIcon = profitLoss >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';

            const cashOutAmount = marketPrice * position.quantity;
            currentUser.balance += cashOutAmount;

            // Update the mockProps array so the change persists
            const mockProp = mockProps.find(p => p.id === prop.id);
            if (mockProp) {
                mockProp.available_contracts += 1;
            }

            // Remove from portfolio
            userPortfolio = userPortfolio.filter(p => p !== position);

            // Cancel any pending sell orders for this contract
            cancelPendingSellOrders(prop.id, tradingProp.type);

            // Record trade
            recordTrade('CASH_OUT', prop, marketPrice, 'cash_out');

            alert(`Cash out successful! You received $${cashOutAmount.toFixed(2)}. Your profit/loss was $${profitLoss.toFixed(2)}.`);
            loadPortfolio();
            loadMarketData();
            loadPendingOrders();
            loadTradeHistory();
        }




        // Show game schedule
        function showGameSchedule() {
            const scheduleHeader = document.getElementById('game-schedule-header');
            const scheduleContent = document.getElementById('game-schedule-content');
            
            if (!scheduleHeader || !scheduleContent || mockProps.length === 0) return;
            
            // Get all games including doubleheaders - use game_id + time as unique key to handle doubleheaders properly
            const games = {};
            mockProps.forEach(prop => {
                if (prop.formatted_game_time && prop.formatted_game_time !== 'TBD' && prop.game_id) {
                    // Create unique key that includes game_id to handle doubleheaders (same teams, different times)
                    const key = `${prop.game_id}_${prop.formatted_game_time}`;
                    
                    if (!games[key]) {
                        // Extract home team from the game_id format (e.g., "MIL@CHC|2:20 PM ET|0|A" -> CHC is home)
                        let homeTeam = 'Unknown';
                        let awayTeam = prop.player_team;
                        
                        if (prop.game_id && prop.game_id.includes('@')) {
                            const parts = prop.game_id.split('@');
                            if (parts.length >= 2) {
                                awayTeam = parts[0];
                                homeTeam = parts[1].split('|')[0]; // Remove the time part
                            }
                        }
                        
                        games[key] = {
                            time: prop.formatted_game_time,
                            awayTeam: awayTeam,
                            homeTeam: homeTeam,
                            displayName: `${awayTeam} @ ${homeTeam}`,
                            status: prop.status_badge || 'UPCOMING',
                            gameId: prop.game_id
                        };
                    }
                }
            });
            
            // Sort games by time
            const sortedGames = Object.values(games).sort((a, b) => {
                const parseTime = (timeStr) => {
                    const match = timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
                    if (!match) return Infinity;
                    
                    let hour = parseInt(match[1]);
                    const minute = parseInt(match[2]);
                    const period = match[3].toUpperCase();
                    
                    if (period === 'PM' && hour !== 12) hour += 12;
                    if (period === 'AM' && hour === 12) hour = 0;
                    
                    return hour * 60 + minute;
                };
                
                return parseTime(a.time) - parseTime(b.time);
            });
            
            if (sortedGames.length > 0) {
                scheduleHeader.style.display = 'block';
                scheduleContent.innerHTML = `
                    <div class="row">
                        ${sortedGames.map(game => `
                            <div class="col-md-4 mb-2">
                                <div class="badge bg-primary">
                                    <i class="fas fa-clock"></i> ${game.time}
                                </div>
                                <br><small>${game.displayName}</small>
                                <br><small class="badge bg-${getStatusBadgeColor(game.status)}">${game.status}</small>
                            </div>
                        `).join('')}
                    </div>
                `;
            } else {
                scheduleHeader.style.display = 'none';
            }
        }
        
        // Helper function to get status badge color
        function getStatusBadgeColor(status) {
            switch (status) {
                case 'LIVE':
                    return 'danger';
                case 'FINAL':
                    return 'secondary';
                case 'CANCELLED':
                    return 'warning';
                case 'RULED_OUT':
                    return 'secondary';
                case 'OVER_HIT':
                    return 'success';
                case 'PUSH':
                    return 'primary';
                case 'UPCOMING':
                default:
                    return 'success';
            }
        }

        // Filter event listeners
        document.getElementById('sport-filter').addEventListener('change', function() {
            loadMarketData();
            
            // Show/hide stat category filter based on sport selection
            const sportFilter = this.value;
            const statCategoryFilter = document.getElementById('stat-category-container');
            
            if (sportFilter === 'MLB') {
                statCategoryFilter.style.display = 'block';
            } else {
                statCategoryFilter.style.display = 'none';
                // Reset stat category filter when switching away from MLB
                document.getElementById('stat-category-filter').value = '';
            }
        });
        document.getElementById('difficulty-filter').addEventListener('change', loadMarketData);
        document.getElementById('status-filter').addEventListener('change', loadMarketData);
        document.getElementById('stat-category-filter').addEventListener('change', loadMarketData);

        // Leaderboard and Platform Stats Functions
        async function loadLeaderboard() {
            try {
                const response = await fetch(`${API_BASE}/leaderboard/top?limit=10`);
                const data = await response.json();
                
                if (data.success) {
                    renderLeaderboard(data.leaderboard);
                } else {
                    console.error('Error loading leaderboard:', data.error);
                }
            } catch (error) {
                console.error('Error loading leaderboard:', error);
            }
        }

        function renderLeaderboard(leaderboard) {
            const container = document.getElementById('leaderboard-content');
            
            if (!leaderboard || leaderboard.length === 0) {
                container.innerHTML = '<p class="text-muted">No data available</p>';
                return;
            }

            let html = '';
            leaderboard.forEach((user, index) => {
                const profitClass = user.net_profit >= 0 ? 'text-success' : 'text-danger';
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : '';
                
                html += `
                    <div class="d-flex justify-content-between align-items-center mb-2 p-2 border-bottom">
                        <div class="d-flex align-items-center">
                            <span class="me-2">${medal}</span>
                            <div>
                                <div class="fw-bold">${user.full_name}</div>
                                <small class="text-muted">@${user.username}</small>
                            </div>
                        </div>
                        <div class="text-end">
                            <div class="${profitClass} fw-bold">$${user.net_profit.toFixed(2)}</div>
                            <small class="text-muted">$${user.balance.toFixed(2)}</small>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        async function loadPlatformStats() {
            try {
                const response = await fetch(`${API_BASE}/leaderboard/profit`);
                const data = await response.json();
                
                if (data.success) {
                    const profitClass = data.net_profit >= 0 ? 'text-success' : 'text-danger';
                    document.getElementById('platform-profit').innerHTML = 
                        `<span class="${profitClass}">$${data.net_profit.toFixed(2)}</span>`;
                }
            } catch (error) {
                console.error('Error loading platform stats:', error);
            }
        }

        function refreshLeaderboard() {
            loadLeaderboard();
            loadPlatformStats();
        }

        // Initialize
        window.addEventListener('load', () => {
            // Auto-start in demo mode
            showDashboard();
        });

        // Handle cash out for final games
        function handleCashOut(propId) {
            const prop = mockProps.find(p => p.id === propId);
            if (!prop) {
                alert('Prop not found!');
                return;
            }
            
            if (prop.status_badge !== 'FINAL') {
                alert('This game is not final yet!');
                return;
            }
            
            // Find user's position for this prop
            const position = userPortfolio.find(p => p.prop_id === propId);
            if (!position) {
                alert('You don\'t own any contracts for this player!');
                return;
            }
            
            // Calculate payout (in a real system, this would be based on actual results)
            const payout = position.avg_price; // For now, just return the purchase price
            
            // Update user balance
            currentUser.balance += payout;
            
            // Remove from portfolio
            userPortfolio = userPortfolio.filter(p => p !== position);
            
            // Record the cash out
            recordTrade('CASH_OUT', prop, payout, 'cash_out');
            
            alert(`Cash out successful! You received $${payout.toFixed(2)} for your ${prop.player_name} contract.`);
            
            // Refresh displays
            loadMarketData();
            loadPortfolio();
            loadTradeHistory();
        }

        // Handle automatic refunds for cancelled games
        function handleCancelledGameRefunds() {
            // Find all props with cancelled status
            const cancelledProps = mockProps.filter(prop => prop.status_badge === 'CANCELLED');
            
            cancelledProps.forEach(prop => {
                // Find user's position for this prop
                const position = userPortfolio.find(p => p.prop_id === prop.id);
                if (position) {
                    // Calculate refund amount
                    const refundAmount = position.avg_price * position.quantity;
                    
                    // Update user balance
                    currentUser.balance += refundAmount;
                    
                    // Remove from portfolio
                    userPortfolio = userPortfolio.filter(p => p !== position);
                    
                    // Record the refund
                    recordTrade('REFUND', prop, refundAmount, 'cancelled_game');
                    
                    console.log(`Auto-refunded $${refundAmount.toFixed(2)} for ${prop.player_name} (Game cancelled)`);
                }
            });
            
            // Refresh displays if any refunds were processed
            if (cancelledProps.length > 0) {
                loadMarketData();
                loadPortfolio();
                loadTradeHistory();
            }
        }
        
        // Check for cancelled games and process refunds
        function checkForCancelledGames() {
            const hasCancelledGames = mockProps.some(prop => prop.status_badge === 'CANCELLED');
            if (hasCancelledGames) {
                handleCancelledGameRefunds();
            }
        }
        
        // Handle automatic refunds for ruled out players
        function handleRuledOutPlayerRefunds() {
            // Find all props with ruled out status
            const ruledOutProps = mockProps.filter(prop => prop.status_badge === 'RULED_OUT');
            
            ruledOutProps.forEach(prop => {
                // Find user's position for this prop
                const position = userPortfolio.find(p => p.prop_id === prop.id);
                if (position) {
                    // Calculate refund amount
                    const refundAmount = position.avg_price * position.quantity;
                    
                    // Update user balance
                    currentUser.balance += refundAmount;
                    
                    // Remove from portfolio
                    userPortfolio = userPortfolio.filter(p => p !== position);
                    
                    // Record the refund
                    recordTrade('REFUND', prop, refundAmount, 'ruled_out_player');
                    
                    console.log(`Auto-refunded $${refundAmount.toFixed(2)} for ${prop.player_name} (Player ruled out)`);
                }
            });
            
            // Refresh displays if any refunds were processed
            if (ruledOutProps.length > 0) {
                loadMarketData();
                loadPortfolio();
                loadTradeHistory();
            }
        }
        
        // Check for ruled out players and process refunds
        function checkForRuledOutPlayers() {
            const hasRuledOutPlayers = mockProps.some(prop => prop.status_badge === 'RULED_OUT');
            if (hasRuledOutPlayers) {
                handleRuledOutPlayerRefunds();
            }
        }

        // Refresh game statuses from backend
        async function refreshGameStatuses() {
            try {
                console.log('üîÑ Refreshing game statuses from backend...');
                
                // Reload props to get updated statuses
                const realProps = await loadRealMLBProps();
                if (realProps && realProps.length > 0) {
                    mockProps = realProps;
                    console.log('‚úÖ Game statuses refreshed from backend');
                    
                    // Update the display to show new statuses
                    loadMarketData();
                    
                    // Check for any status changes
                    const statusCounts = {};
                    mockProps.forEach(prop => {
                        const status = prop.status_badge || 'UNKNOWN';
                        statusCounts[status] = (statusCounts[status] || 0) + 1;
                    });
                    console.log('üìä Current game status distribution:', statusCounts);
                } else {
                    console.log('‚ö†Ô∏è No props returned from backend refresh');
                }
            } catch (error) {
                console.error('‚ùå Error refreshing game statuses:', error);
            }
        }

        // Handle automatic cash outs for over props that have hit
        function handleOverHitCashouts() {
            // Find all props with over hit status
            const overHitProps = mockProps.filter(prop => prop.status_badge === 'OVER_HIT');
            
            overHitProps.forEach(prop => {
                // Find user's position for this prop
                const position = userPortfolio.find(p => p.prop_id === prop.id);
                if (position) {
                    // Calculate cash out amount (full value for hitting over)
                    const cashOutAmount = position.avg_price * position.quantity;
                    
                    // Update user balance
                    currentUser.balance += cashOutAmount;
                    
                    // Remove from portfolio
                    userPortfolio = userPortfolio.filter(p => p !== position);
                    
                    // Record the cash out
                    recordTrade('OVER_HIT_CASHOUT', prop, cashOutAmount, 'over_hit_automatic');
                    
                    console.log(`Auto-cashed out $${cashOutAmount.toFixed(2)} for ${prop.player_name} (Over target hit)`);
                }
            });
            
            // Refresh displays if any cash outs were processed
            if (overHitProps.length > 0) {
                loadMarketData();
                loadPortfolio();
                loadTradeHistory();
            }
        }
        
        // Check for over hit props and process cash outs
        function checkForOverHitProps() {
            const hasOverHitProps = mockProps.some(prop => prop.status_badge === 'OVER_HIT');
            if (hasOverHitProps) {
                handleOverHitCashouts();
            }
        }
        
        // Handle automatic refunds for PUSH (exact on the line)
        function handlePushRefunds() {
            const pushProps = mockProps.filter(prop => prop.status_badge === 'PUSH');
            pushProps.forEach(prop => {
                const position = userPortfolio.find(p => p.prop_id === prop.id);
                if (position) {
                    const refundAmount = position.avg_price * position.quantity;
                    currentUser.balance += refundAmount;
                    userPortfolio = userPortfolio.filter(p => p !== position);
                    recordTrade('REFUND_PUSH', prop, refundAmount, 'push_refund');
                    console.log(`Auto-refunded $${refundAmount.toFixed(2)} for ${prop.player_name} (PUSH)`);
                }
            });
            if (pushProps.length > 0) {
                loadMarketData();
                loadPortfolio();
                loadTradeHistory();
            }
        }
        
        // Check for pushes and process refunds
        function checkForPushes() {
            const hasPushes = mockProps.some(prop => prop.status_badge === 'PUSH');
            if (hasPushes) handlePushRefunds();
        }

        // ========================================
        // WEBSOCKET LIVE UPDATES
        // ========================================
        
        let websocket = null;
        let isWebSocketConnected = false;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        
        // Initialize WebSocket connection
        function initWebSocket() {
            try {
                console.log('üîå Initializing WebSocket connection...');
                websocket = new WebSocket('ws://localhost:8765');
                
                websocket.onopen = function(event) {
                    console.log('‚úÖ WebSocket connected successfully');
                    isWebSocketConnected = true;
                    reconnectAttempts = 0;
                    updateConnectionStatus(true);
                    
                    // Subscribe to user updates if logged in
                    if (currentUser && currentUser.id) {
                        websocket.send(JSON.stringify({
                            type: 'subscribe_user',
                            user_id: currentUser.id
                        }));
                    }
                };
                
                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(data);
                    } catch (error) {
                        console.error('‚ùå Error parsing WebSocket message:', error);
                    }
                };
                
                websocket.onclose = function(event) {
                    console.log('üîå WebSocket connection closed');
                    isWebSocketConnected = false;
                    updateConnectionStatus(false);
                    
                    // Attempt to reconnect
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        console.log(`üîÑ Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                        setTimeout(initWebSocket, 5000);
                } else {
                        console.error('‚ùå Max reconnection attempts reached');
                    }
                };
                
                websocket.onerror = function(error) {
                    console.error('‚ùå WebSocket error:', error);
                    isWebSocketConnected = false;
                    updateConnectionStatus(false);
                };
                
            } catch (error) {
                console.error('‚ùå Error initializing WebSocket:', error);
            }
        }
        
        // Handle incoming WebSocket messages
        function handleWebSocketMessage(data) {
            console.log('üì® WebSocket message received:', data);
            
            switch (data.type) {
                case 'game_status_update':
                    handleGameStatusUpdate(data);
                    break;
                case 'prop_result_update':
                    handlePropResultUpdate(data);
                    break;
                case 'balance_update':
                    if (data.user_id === currentUser?.id) {
                        handleBalanceUpdate(data);
                    }
                    break;
                case 'initial_state':
                    handleInitialState(data);
                    break;
                case 'subscription_confirmed':
                    console.log('‚úÖ User subscription confirmed');
                    break;
                case 'pong':
                    // Handle ping/pong for connection health
                    break;
                default:
                    console.log('‚ö†Ô∏è Unknown WebSocket message type:', data.type);
            }
        }
        
        // Handle game status updates
        function handleGameStatusUpdate(data) {
            console.log(`üîÑ Game ${data.game_id} status: ${data.old_status} ‚Üí ${data.new_status}`);
            
            // Update props with new game status
            let hasUpdates = false;
            mockProps.forEach(prop => {
                if (prop.game_id === data.game_id) {
                    const oldStatus = prop.status_badge;
                    prop.status_badge = data.new_status;
                    
                    if (oldStatus !== data.new_status) {
                        hasUpdates = true;
                        console.log(`üìä Updated ${prop.player_name} status: ${oldStatus} ‚Üí ${data.new_status}`);
                    }
                }
            });
            
            if (hasUpdates) {
                // Refresh the display
                loadMarketData();
                
                // Show notification
                showNotification(`Game status updated: ${data.old_status} ‚Üí ${data.new_status}`);
                
                // Handle automatic actions based on status change
                if (data.new_status === 'LIVE') {
                    handleGameStarted(data.game_id);
                } else if (data.new_status === 'FINAL') {
                    handleGameFinished(data.game_id);
                }
            }
        }
        
        // Handle prop result updates
        function handlePropResultUpdate(data) {
            console.log(`üéØ Prop ${data.prop_id} result: ${data.result} (actual: ${data.actual_value})`);
            
            // Find and update the prop
            const prop = mockProps.find(p => p.id === data.prop_id);
            if (prop) {
                prop.status_badge = data.result;
                prop.actual_value = data.actual_value;
                prop.result_timestamp = data.timestamp;
                
                // Refresh the display
                loadMarketData();
                
                // Show result notification
                const resultText = data.result === 'PUSH' ? 'PUSH!' : `${data.result} HIT!`;
                showNotification(`Prop ${prop.player_name}: ${resultText} (Actual: ${data.actual_value})`);
                
                // Handle automatic actions
                if (data.result === 'PUSH') {
                    handlePushRefunds();
                } else if (data.result === 'OVER_HIT' || data.result === 'UNDER_HIT') {
                    handlePropHit(data.result, prop);
                }
            }
        }
        
        // Handle balance updates
        function handleBalanceUpdate(data) {
            console.log(`üí∞ Balance update: $${data.old_balance} ‚Üí $${data.new_balance} (${data.change_reason})`);
            
            if (currentUser) {
                currentUser.balance = data.new_balance;
                
                // Refresh displays
                loadPortfolio();
                loadTradeHistory();
                
                // Show balance change notification
                const changeText = data.change_amount >= 0 ? `+$${data.change_amount.toFixed(2)}` : `-$${Math.abs(data.change_amount).toFixed(2)}`;
                showNotification(`Balance updated: ${changeText} (${data.change_reason})`);
            }
        }
        
        // Handle initial state from WebSocket
        function handleInitialState(data) {
            console.log('üìä Received initial state from WebSocket');
            
            // Update game statuses
            if (data.game_statuses) {
                Object.entries(data.game_statuses).forEach(([gameId, status]) => {
                    mockProps.forEach(prop => {
                        if (prop.game_id === gameId) {
                            prop.status_badge = status;
                        }
                    });
                });
            }
            
            // Update prop results
            if (data.prop_results) {
                Object.entries(data.prop_results).forEach(([propId, result]) => {
                    const prop = mockProps.find(p => p.id === propId);
                    if (prop) {
                        prop.status_badge = result.result;
                        prop.actual_value = result.actual_value;
                    }
                });
            }
            
            // Refresh display
            loadMarketData();
        }
        
        // Handle game started (status changed to LIVE)
        function handleGameStarted(gameId) {
            console.log(`üöÄ Game ${gameId} has started!`);
            
            // Start live price updates for this game's props
            startLivePriceUpdates(gameId);
            
            // Show notification
            showNotification('Game has started! Live updates are now active.');
        }
        
        // Handle game finished (status changed to FINAL)
        function handleGameFinished(gameId) {
            console.log(`üèÅ Game ${gameId} has finished!`);
            
            // Stop live price updates for this game
            stopLivePriceUpdates(gameId);
            
            // Process final results
            processGameResults(gameId);
            
            // Show notification
            showNotification('Game has finished! Processing final results...');
        }
        
        // Start live price updates for a game
        function startLivePriceUpdates(gameId) {
            // This would integrate with live pricing API
            // For now, simulate price fluctuations
            const gameProps = mockProps.filter(prop => prop.game_id === gameId);
            
            gameProps.forEach(prop => {
                if (!prop.livePriceInterval) {
                    prop.livePriceInterval = setInterval(() => {
                        // Simulate price changes
                        const change = (Math.random() - 0.5) * 2; // ¬±$1
                        prop.live_contract_price = Math.max(0, Math.min(100, (prop.live_contract_price || 50) + change));
                        
                        // Update display
                        updatePropPrice(prop.id, prop.live_contract_price);
                    }, 5000); // Update every 5 seconds
                }
            });
        }
        
        // Stop live price updates for a game
        function stopLivePriceUpdates(gameId) {
            const gameProps = mockProps.filter(prop => prop.game_id === gameId);
            
            gameProps.forEach(prop => {
                if (prop.livePriceInterval) {
                    clearInterval(prop.livePriceInterval);
                    prop.livePriceInterval = null;
                }
            });
        }
        
        // Update prop price in the display
        function updatePropPrice(propId, newPrice) {
            const priceElement = document.querySelector(`[data-prop-id="${propId}"] .live-price`);
            if (priceElement) {
                priceElement.textContent = `$${newPrice.toFixed(2)}`;
                priceElement.classList.add('price-update');
                
                // Remove animation class after animation
                setTimeout(() => {
                    priceElement.classList.remove('price-update');
                }, 1000);
            }
        }
        
        // Process final game results
        function processGameResults(gameId) {
            const gameProps = mockProps.filter(prop => prop.game_id === gameId);
            
            // This would integrate with final stats API
            // For now, simulate final results
            gameProps.forEach(prop => {
                // Simulate final result
                const finalValue = Math.floor(Math.random() * 10) + 1;
                prop.actual_value = finalValue;
                
                // Determine result
                if (finalValue > prop.line_value) {
                    prop.status_badge = 'OVER_HIT';
                } else if (finalValue < prop.line_value) {
                    prop.status_badge = 'UNDER_HIT';
                } else {
                    prop.status_badge = 'PUSH';
                }
            });
            
            // Refresh display
            loadMarketData();
        }
        
        // Handle prop hit (OVER or UNDER)
        function handlePropHit(result, prop) {
            const position = userPortfolio.find(p => p.prop_id === prop.id);
            if (position) {
                if (result === 'OVER_HIT' && position.direction === 'over') {
                    // User won
                    const winnings = position.avg_price * position.quantity * 2; // 2x payout
                    currentUser.balance += winnings;
                    
                    // Remove from portfolio
                    userPortfolio = userPortfolio.filter(p => p !== position);
                    
                    // Record the win
                    recordTrade('PROP_WIN', prop, winnings, 'prop_hit');
                    
                    showNotification(`üéâ You won $${winnings.toFixed(2)} on ${prop.player_name}!`);
                } else if (result === 'UNDER_HIT' && position.direction === 'under') {
                    // User won
                    const winnings = position.avg_price * position.quantity * 2; // 2x payout
                    currentUser.balance += winnings;
                    
                    // Remove from portfolio
                    userPortfolio = userPortfolio.filter(p => p !== position);
                    
                    // Record the win
                    recordTrade('PROP_WIN', prop, winnings, 'prop_hit');
                    
                    showNotification(`üéâ You won $${winnings.toFixed(2)} on ${prop.player_name}!`);
                } else {
                    // User lost
                    showNotification(`üòî You lost on ${prop.player_name} (${result})`);
                }
                
                // Refresh displays
                loadPortfolio();
                loadTradeHistory();
            }
        }
        
        // Show notification
        function showNotification(message) {
            // Create toast notification
            const toast = document.createElement('div');
            toast.createElement('div');
            toast.className = 'toast-notification';
            toast.innerHTML = `
                <div class="toast-header">
                    <strong>Live Update</strong>
                    <button type="button" class="btn-close" onclick="this.parentElement.parentElement.remove()"></button>
                </div>
                <div class="toast-body">
                    ${message}
                </div>
            `;
            
            // Add to page
            document.body.appendChild(toast);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.remove();
                }
            }, 5000);
        }
        
        // Update connection status display
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('websocket-status');
            if (statusElement) {
                statusElement.className = `badge ${connected ? 'bg-success' : 'bg-danger'}`;
                statusElement.textContent = connected ? 'üü¢ Live' : 'üî¥ Offline';
            }
        }
        
        // Send ping to keep connection alive
        function sendPing() {
            if (websocket && isWebSocketConnected) {
                websocket.send(JSON.stringify({ type: 'ping' }));
            }
        }
        
        // Initialize WebSocket when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize WebSocket after a short delay to ensure page is ready
            setTimeout(() => {
                initWebSocket();
                
                // Send ping every 30 seconds to keep connection alive
                setInterval(sendPing, 30000);
            }, 1000);
        });
    </script>
</body>
</html>
